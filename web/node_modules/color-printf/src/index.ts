import { format as utilFormat } from 'util';
// ANSI control code constants
const RESET = '\x1b[0m';

// Supported color name types
type ColorName = 
    | 'reset' 
    | 'black' | 'red' | 'green' | 'yellow' | 'blue' | 'magenta' | 'cyan' | 'white' | 'gray'
    | 'bgblack' | 'bgred' | 'bggreen' | 'bgyellow' | 'bgblue' | 'bgmagenta' | 'bgcyan' | 'bgwhite' | 'bggray';

// RGB color interface
interface RgbColor {
    r: number;
    g: number;
    b: number;
}

/**
 * Detect if terminal supports 24-bit true color
 */
function isTrueColorSupported(): boolean {
    const term = process.env.TERM || '';
    const colorTerm = process.env.COLORTERM || '';
    return colorTerm === 'truecolor' || colorTerm === '24bit' || term.includes('256color');
}

/**
 * Convert hex color to RGB values
 * Supports: #ff0000, ff0000, #f00, f00
 */
function hexToRgb(hex: string): RgbColor | null {
    // Handle # prefix
    const cleanHex = hex.startsWith('#') ? hex.slice(1).toLowerCase() : hex.toLowerCase();
    
    // Handle 3-digit shorthand (#f00 -> #ff0000)
    let fullHex = cleanHex;
    if (cleanHex.length === 3) {
        fullHex = cleanHex.split('').map(c => c + c).join('');
    }
    
    // Validate 6-digit hex format
    if (!/^[0-9a-f]{6}$/.test(fullHex)) {
        return null;
    }
    
    // Parse RGB values
    return {
        r: Math.min(255, parseInt(fullHex.substring(0, 2), 16)),
        g: Math.min(255, parseInt(fullHex.substring(2, 4), 16)),
        b: Math.min(255, parseInt(fullHex.substring(4, 6), 16))
    };
}

/**
 * Convert RGB to ANSI color code
 * Automatically chooses 24-bit or 8-bit mode based on terminal support
 */
function rgbToAnsi(rgb: RgbColor, isBackground: boolean): string {
    if (isTrueColorSupported()) {
        // 24-bit true color mode
        const baseCode = isBackground ? '48;2' : '38;2';
        return `\x1b[${baseCode};${rgb.r};${rgb.g};${rgb.b}m`;
    } else {
        // 8-bit color fallback (compatible with older terminals)
        if (rgb.r > 200 && rgb.g < 100 && rgb.b < 100) return `\x1b[${isBackground ? 41 : 31}m`; // Red tones
        if (rgb.g > 200 && rgb.r < 100 && rgb.b < 100) return `\x1b[${isBackground ? 42 : 32}m`; // Green tones
        if (rgb.b > 200 && rgb.r < 100 && rgb.g < 100) return `\x1b[${isBackground ? 44 : 34}m`; // Blue tones
        if (rgb.r > 200 && rgb.g > 200 && rgb.b < 100) return `\x1b[${isBackground ? 43 : 33}m`; // Yellow tones
        if (rgb.r > 200 && rgb.b > 200 && rgb.g < 100) return `\x1b[${isBackground ? 45 : 35}m`; // Magenta tones
        if (rgb.g > 200 && rgb.b > 200 && rgb.r < 100) return `\x1b[${isBackground ? 46 : 36}m`; // Cyan tones
        
        // Gray scale handling
        const brightness = (rgb.r * 0.299 + rgb.g * 0.587 + rgb.b * 0.114) / 255;
        if (brightness < 0.2) return `\x1b[${isBackground ? 40 : 30}m`;   // Black
        if (brightness < 0.4) return `\x1b[${isBackground ? 100 : 90}m`;  // Dark gray
        if (brightness < 0.7) return `\x1b[${isBackground ? 47 : 37}m`;   // Light gray
        return `\x1b[${isBackground ? 107 : 97}m`;                        // White
    }
}

/**
 * Color name to ANSI code mapping
 */
const colorNameToAnsi: Record<ColorName, string> = {
    reset: RESET,
    black: '\x1b[30m',
    red: '\x1b[31m',
    green: '\x1b[32m',
    yellow: '\x1b[33m',
    blue: '\x1b[34m',
    magenta: '\x1b[35m',
    cyan: '\x1b[36m',
    white: '\x1b[37m',
    gray: '\x1b[90m', // Bright black as gray
    bgblack: '\x1b[40m',
    bgred: '\x1b[41m',
    bggreen: '\x1b[42m',
    bgyellow: '\x1b[43m',
    bgblue: '\x1b[44m',
    bgmagenta: '\x1b[45m',
    bgcyan: '\x1b[46m',
    bgwhite: '\x1b[47m',
    bggray: '\x1b[100m' // Bright black background as gray background
};

/**
 * Parse color-tagged string without requiring ending #
 */
function parseColorTags(str: string): string {
    let result = '';
    let i = 0;
    const len = str.length;
    let currentColorCode = ''; // Currently applied color code
    
    while (i < len) {
        if (str[i] === '#') {
            // Reset previous color before applying new one
            if (currentColorCode) {
                result += RESET;
                currentColorCode = '';
            }
            
            const startPos = i;
            i++;
            let isBackground = false;
            
            // Detect background color marker (##)
            if (i < len && str[i] === '#') {
                isBackground = true;
                i++;
            }
            
            // Extract color value until colon (: or ：)
            let colorValue = '';
            let colonFound = false;
            while (i < len && !colonFound) {
                if (str[i] === ':' || str[i] === '：') {
                    colonFound = true;
                    i++; // Skip colon
                } else {
                    colorValue += str[i];
                    i++;
                }
            }
            
            // Must find colon to be valid color marker
            if (colonFound) {
                const lowerColor = colorValue.trim().toLowerCase();
                let colorCode = '';
                
                // Try color name
                if (lowerColor in colorNameToAnsi) {
                    colorCode = colorNameToAnsi[lowerColor as ColorName];
                } 
                // Try hex color
                else {
                    const rgb = hexToRgb(lowerColor);
                    if (rgb) {
                        colorCode = rgbToAnsi(rgb, isBackground);
                    }
                }
                
                if (colorCode) {
                    currentColorCode = colorCode;
                    result += colorCode;
                } else {
                    // Invalid color, output marker as-is
                    result += str.substring(startPos, i);
                }
            } 
            // No colon found, treat as normal text
            else {
                result += str.substring(startPos, i);
            }
        } else {
            // Add normal character
            result += str[i];
            i++;
        }
    }
    
    // Ensure final color reset
    if (currentColorCode) {
        result += RESET;
    }
    
    return result;
}

/**
 * Core formatting function that returns colored string
 */
function formatColored(format: string, ...args: any[]): string {
    try {
        const formattedStr = utilFormat(format, ...args);
        return parseColorTags(formattedStr);
    } catch (error) {
        // Fallback to unformatted string on error
        console.error('Color format error:', error);
        return utilFormat(format, ...args);
    }
}

/**
 * Core printing function
 */
function printColored(format: string, ...args: any[]): void {
    try {
        const coloredStr = formatColored(format, ...args);
        process.stdout.write(coloredStr + '\n');
    } catch (error) {
        // Fallback to normal print on error
        console.log(format, ...args);
        console.error('Color print error:', error);
    }
}

/**
 * Main color print utility object
 */
export const color = {
    /**
     * Prints colored formatted string
     * @param format Format string with color markers
     * @param args Format arguments
     */
    printf: printColored,
    
    /**
     * Returns colored formatted string without printing
     * @param format Format string with color markers
     * @param args Format arguments
     * @returns Formatted string with ANSI color codes
     */
    format: formatColored
};

/**
 * Generate color shortcut functions
 */
type ColorFunction = (format: string, ...args: any[]) => void;

// Foreground colors
const foregroundColors: Record<string, ColorFunction> = {
    black: (format, ...args) => printColored(`#black: ${format}`, ...args),
    red: (format, ...args) => printColored(`#red: ${format}`, ...args),
    green: (format, ...args) => printColored(`#green: ${format}`, ...args),
    yellow: (format, ...args) => printColored(`#yellow: ${format}`, ...args),
    blue: (format, ...args) => printColored(`#blue: ${format}`, ...args),
    magenta: (format, ...args) => printColored(`#magenta: ${format}`, ...args),
    cyan: (format, ...args) => printColored(`#cyan: ${format}`, ...args),
    white: (format, ...args) => printColored(`#white: ${format}`, ...args),
    gray: (format, ...args) => printColored(`#gray: ${format}`, ...args)
};

// Background colors
const backgroundColors: Record<string, ColorFunction> = {
    bgBlack: (format, ...args) => printColored(`##black: ${format}`, ...args),
    bgRed: (format, ...args) => printColored(`##red: ${format}`, ...args),
    bgGreen: (format, ...args) => printColored(`##green: ${format}`, ...args),
    bgYellow: (format, ...args) => printColored(`##yellow: ${format}`, ...args),
    bgBlue: (format, ...args) => printColored(`##blue: ${format}`, ...args),
    bgMagenta: (format, ...args) => printColored(`##magenta: ${format}`, ...args),
    bgCyan: (format, ...args) => printColored(`##cyan: ${format}`, ...args),
    bgWhite: (format, ...args) => printColored(`##white: ${format}`, ...args),
    bgGray: (format, ...args) => printColored(`##gray: ${format}`, ...args)
};

// Export all color shortcut functions
export const {
    black,
    red,
    green,
    yellow,
    blue,
    magenta,
    cyan,
    white,
    gray
} = foregroundColors;

export const {
    bgBlack,
    bgRed,
    bgGreen,
    bgYellow,
    bgBlue,
    bgMagenta,
    bgCyan,
    bgWhite,
    bgGray
} = backgroundColors;