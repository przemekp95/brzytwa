import * as esbuild from 'esbuild';
import fs from 'fs-extra';
import path from 'path';
import { promisify } from 'util';
import type { JestTsOptions, CacheData } from './types';

// 手动定义Jest转译器所需类型（避免依赖外部模块）
interface JestConfig {
  rootDir: string;
  [key: string]: unknown;
}

interface ProcessOptions {
  config: JestConfig;
  globals: Record<string, unknown>;
  [key: string]: unknown;
}

interface TransformResult {
  code: string;
  map?: string | null;
}

interface TransformOptions {
  // Jest 30.x 强制要求的同步方法
  process: (
    sourceText: string,
    sourcePath: string,
    options: ProcessOptions
  ) => TransformResult;
  // 异步方法（可选，但推荐）
  processAsync?: (
    sourceText: string,
    sourcePath: string,
    options: ProcessOptions
  ) => Promise<TransformResult>;
  version?: string;
  [key: string]: unknown;
}

// 类型守卫：判断是否为非空对象
const isObject = (value: unknown): value is Record<string, unknown> => {
  return typeof value === 'object' && value !== null;
};

// 类型守卫：验证转译结果
const isValidTransformResult = (
  result: unknown
): result is TransformResult => {
  return isObject(result) && typeof (result as { code: unknown }).code === 'string';
};

const DEFAULT_CACHE_DIR = '<rootDir>/.jest-ts-cache';

const resolveCacheDir = (cacheDir: string, rootDir: string): string => {
  return cacheDir.replace('<rootDir>', rootDir);
};

// 同步读取缓存（适配process同步方法）
const readCacheSync = (
  filePath: string,
  cacheDir: string
): { code: string; map?: string } | null => {
  try {
    const cacheFile = path.join(cacheDir, `${path.basename(filePath)}.json`);
    if (!fs.pathExistsSync(cacheFile)) return null;

    const fileStat = fs.statSync(filePath);
    const cacheStat = fs.statSync(cacheFile);

    if (fileStat.mtimeMs > cacheStat.mtimeMs) {
      fs.removeSync(cacheFile);
      return null;
    }

    const cacheData = fs.readJsonSync(cacheFile) as CacheData;
    return isValidTransformResult(cacheData) 
      ? { code: cacheData.code, map: cacheData.map } 
      : null;
  } catch (error) {
    console.warn(`[jest-ts] 同步缓存读取失败 (${filePath}):`, error);
    return null;
  }
};

// 同步写入缓存
const writeCacheSync = (
  filePath: string,
  cacheDir: string,
  data: { code: string; map?: string }
): void => {
  try {
    fs.ensureDirSync(cacheDir);
    const cacheFile = path.join(cacheDir, `${path.basename(filePath)}.json`);
    fs.writeJsonSync(cacheFile, { ...data, mtime: Date.now() } as CacheData);
  } catch (error) {
    console.warn(`[jest-ts] 同步缓存写入失败 (${filePath}):`, error);
  }
};

// 核心同步转译函数（供process方法使用）
const transformTsCodeSync = (
  sourceText: string,
  sourcePath: string,
  options: Partial<JestTsOptions>,
  rootDir: string
): { code: string; map?: string } => {
  // 非TS/TSX文件直接返回原始内容
  if (!sourcePath.endsWith('.ts') && !sourcePath.endsWith('.tsx')) {
    return { code: sourceText };
  }

  const finalOptions: JestTsOptions = {
    cacheDirectory: resolveCacheDir(DEFAULT_CACHE_DIR, rootDir),
    typeCheck: false,
    tsconfigPath: path.resolve(rootDir, 'tsconfig.json'),
    target: 'node16',
    format: 'cjs',
    esbuildOptions: {},
    ...options
  };

  // 尝试使用缓存
  const cachedResult = readCacheSync(sourcePath, finalOptions.cacheDirectory);
  if (cachedResult) {
    return cachedResult;
  }

  try {
    // 使用esbuild同步转译
    const esbuildResult = esbuild.transformSync(sourceText, {
      loader: sourcePath.endsWith('.tsx') ? 'tsx' : 'ts',
      target: finalOptions.target,
      format: finalOptions.format as esbuild.Format,
      sourcemap: 'inline',
      banner: '"use strict;"',
      ...finalOptions.esbuildOptions
    });

    const transformResult = {
      code: esbuildResult.code,
      map: esbuildResult.map || undefined
    };

    if (isValidTransformResult(transformResult)) {
      writeCacheSync(sourcePath, finalOptions.cacheDirectory, transformResult);
      return transformResult;
    }
  } catch (error) {
    console.error(`[jest-ts] 同步转译失败 (${sourcePath}):`, error);
  }

  return { code: sourceText };
};

// 异步转译函数（供processAsync使用）
export const transformTsCode = async (
  sourceText: string,
  sourcePath: string,
  options: Partial<JestTsOptions>,
  rootDir: string
): Promise<{ code: string; map?: string }> => {
  // 复用同步逻辑，通过promisify转换为异步
  return new Promise((resolve) => {
    resolve(transformTsCodeSync(sourceText, sourcePath, options, rootDir));
  });
};

// 转译器实现：同时提供process（同步）和processAsync（异步）
export const transformer: TransformOptions = {
  /**
   * 同步处理方法（Jest 30.x 强制要求）
   */
  process(
    sourceText: string,
    sourcePath: string,
    options: ProcessOptions
  ): TransformResult {
    const rootDir = options.config.rootDir;
    const userOptions = (options.globals as Record<string, any>)?.['jest-ts'] || {};

    const result = transformTsCodeSync(sourceText, sourcePath, userOptions, rootDir);

    if (!isValidTransformResult(result)) {
      console.error(`[jest-ts] 同步转译结果无效 (${sourcePath})`);
      return { code: sourceText };
    }

    return result;
  },

  /**
   * 异步处理方法（推荐使用）
   */
  processAsync: async (
    sourceText: string,
    sourcePath: string,
    options: ProcessOptions
  ): Promise<TransformResult> => {
    return transformTsCode(sourceText, sourcePath, (options.globals as Record<string, any>)?.['jest-ts'] || {}, options.config.rootDir);
  },

  // 版本标识
  version: '1.0.0'
};

export default transformer;
